<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title></title>
<style type="text/css">
svg {
  background: #333;
}
svg.grab { cursor: grab }
svg.grabbing { cursor: grabbing }
g {
  transition: transform 0.1s ease-out;
  /**/
}
</style>
<script type="module">
const createSvgElement = (t, props, children) => {
  const el = document.createElementNS('http://www.w3.org/2000/svg', t)
  for (const key of Object.keys(props)) {
    const value = props[key]
    el.setAttributeNS(null, key, value)
  }

  if (!children) return el  

  for (let child of Array.isArray(children) ? children : [children]) {
    if (!child) continue
    el.appendChild(child instanceof Element
      ? child
      : document.createTextNode(String(child)))
  }

  return el
}

const create = (t, ...args) => args.length
  ? createSvgElement(t, ...args)
  : createSvgElement.bind(null, t)

const Rect = create('rect')
const Circle = create('circle')
const Path = create('path')

const invertParams = fn => (x1, y1, x2, y2) => x1 > x2
  ? fn(x1, y1, x2, y2)
  : fn(x2, y2, x1, y1)

const getLink = invertParams((x1, y1, x2, y2) => {
  const w = Math.abs(x1 - x2)
  const h = Math.abs(y1 - y2)
  if (x1 === x2 || y1 === y2 || w === h) return `M${x1},${y1}L${x2},${y2}`

  const e = -Math.min(w, h)
  const t = (Math.max(w, h) + e) / -2
  if (y1 > y2) {
    return h > w
      ? `M${x1},${y1}v${t}l${e},${e}v${t}`
      : `M${x1},${y1}h${t}l${e},${e}h${t}`
  }
  return h > w
    ? `M${x1},${y1}v${-t}l${e},${-e}v${-t}`
    : `M${x1},${y1}h${t}l${e},${-e}h${t}`
})

const nextPowerOf2 = x => Math.pow(2, Math.ceil(Math.log(x) / Math.log(2)))
const prevPowerOf2 = x => Math.pow(2, Math.floor(Math.log(x) / Math.log(2)))

const isNear = n => {
  const decimals = n - ~~(n)
  return decimals < 0.3 || decimals > 0.7
}

const getClickName = e => {
  switch (e.which) {
    case 1: return 'leftclick'
    case 2: return 'middleclick'
    case 3: return 'rightclick'
    default: {
      switch (e.button) {
        case 1: return 'leftclick'
        case 2: return 'rightclick'
        case 4: return 'middleclick'
      }
    }
  }
}

const init = (params = {}) => {
  const S = params.size || 21
  const SS = S * S

  const linkPreview = Path({
    fill: 'none',
    stroke: 'rgba(255,255,255,0.15)',
    'stroke-linecap': 'round',
    'stroke-width': 0.1,
  })
  const svg = create('svg')({ tabindex: -1, viewBox: `-0.5, -0.5, ${S}, ${S}` })
  const group = create('g')({})
  const hoverMarker = Circle({
    cx: Math.floor(S/2),
    cy: Math.floor(S/2),
    r: 0.2,
    fill: 'transparent',
    'stroke-width': 0.05,
    stroke: `hsla(0,0%,100%,0.2)`
  })

  const grid = [ ...Array(SS).keys() ]
    .map(n => Circle({
      cx: n % S,
      cy: Math.floor(n / S),
      r: 0.02,
      fill: `#999`
    }))

  // STATE
  const graph = {}
  const inputsUp = new Set()
  const inputsDown = new Map()
  const centerX = S/2 - 0.5
  const centerY = S/2 - 0.5
  let scale = 1
  let prevScale = 1
  let mouseX = -1
  let mouseY = -1
  let mouseRelX = centerY
  let mouseRelY = centerX
  let posX = 0
  let posY = 0
  let hoverX = -1
  let hoverY = -1
  let nearX = -1
  let nearY = -1
  let hoverPoint
  let selectedPoint
  let drag
  let bounding
  let now = Date.now()

  const dispatch = params.listenner || (() => {})
  const events = new Set(['init'])
  const handle = eventName => events.has(eventName)
    ? events.delete(eventName) && true
    : false

  const isUp = name => inputsUp.has(name)
  const isDown = name => inputsDown.get(name) > now
  const isHold = name => inputsDown.get(name)
  const getHoldedDuration = name => Math.max(0, (now - inputsDown.get(name))) || 0

  const applyPanAndScale = () => {
    const scaleD = scale / prevScale
    const modX = drag ? (mouseX - drag.x) / bounding.width * S : 0
    const modY = drag ? (mouseY - drag.y) / bounding.height * S : 0
    const x = scaleD * ((modX + posX) - mouseRelX) + mouseRelX
    const y = scaleD * ((modY + posY) - mouseRelY) + mouseRelY
    const transform = `matrix(${scale},0,0,${scale},${x},${y})`

    group.setAttributeNS(null, 'transform', transform)

    prevScale = scale
    posX = scaleD * (posX - mouseRelX) + mouseRelX
    posY = scaleD * (posY - mouseRelY) + mouseRelY
  }

  const drawSelection = () => {
    if (selectedPoint) {
      linkPreview.removeAttributeNS(null, 'display')
      linkPreview.setAttributeNS(null, 'd', hoverPoint
        ? getLink(selectedPoint.x, selectedPoint.y, nearX, nearY)
        : getLink(selectedPoint.x, selectedPoint.y, hoverX, hoverY))
    } else {
      linkPreview.setAttributeNS(null, 'display', 'none')
    }

    if (hoverPoint) {
      hoverMarker.removeAttributeNS(null, 'display')
      hoverMarker.setAttributeNS(null, 'cx', nearX)
      hoverMarker.setAttributeNS(null, 'cy', nearY)
    } else {
      hoverMarker.setAttributeNS(null, 'display', 'none')
    }
  }

  const addLink = (start, end) => {
    graph[start.key].links.push(end.key)
    group.appendChild(Path({
      fill: 'none',
      stroke: 'rgba(255,255,255,0.3)',
      'stroke-linecap': 'round',
      'stroke-width': 0.1,
      d: getLink(start.x, start.y, end.x, end.y)
    }))

    dispatch('ADD_LINK', { start, end })
  }

  const addPoint = (x, y) => {
    const elem = Circle({ cx: x, cy: y, r: 0.15, fill: `#ddd` })
    const key = x * S + y
    const point = graph[key] = { elem, x, y, key, links: [] }
    group.prepend(elem)
    dispatch('ADD_POINT', point)
  }

  const executeUpdate = () => {
    if (handle('blur')) {
      // On window blur we want to remove all keys because we can't catch
      // key up event.
      for (const [name] of inputsDown) {
        inputsUp.add(name)
      }
    }

    if (handle('resize') || handle('init')) {
      bounding = svg.getBoundingClientRect()
      applyPanAndScale()
    }

    if (isDown('=')) {
      scale = prevPowerOf2(scale * 2)
      applyPanAndScale()
    }

    if (isDown('+')) {
      scale = scale * 1.2
      applyPanAndScale()
    }

    if (isDown('-')) {
      scale = nextPowerOf2(scale / 2)
      applyPanAndScale()
    }

    if (isDown(' ')) {
      svg.classList.add('grab')
    }

    if (isUp(' ')) {
      svg.classList.remove('grab')
    }

    if (isDown('_')) {
      scale = scale * 0.8
      applyPanAndScale()
    }

    if (isDown('Escape')) {
      selectedPoint = undefined
      drawSelection()
    }

    if (isDown('leftclick')) {
      if (isHold(' ')) {
        drag = { x: mouseX, y: mouseY }
        svg.classList.add('grabbing')
      } else if (hoverPoint) {
        if (selectedPoint) {
          addLink(selectedPoint, hoverPoint)
          selectedPoint = undefined
        } else {
          selectedPoint = hoverPoint
        }
      } else {
        drag = { x: mouseX, y: mouseY }
        svg.classList.add('grabbing')
      }
    }

    if (isUp('leftclick')) {
      if (drag) {
        posX = (mouseX - drag.x) / bounding.width * S + posX
        posY = (mouseY - drag.y) / bounding.height * S + posY
        drag = undefined
        svg.classList.remove('grabbing')
      } else if (selectedPoint) {
        if (getHoldedDuration('leftclick') > 300) {
          hoverPoint && addLink(selectedPoint, hoverPoint)
          selectedPoint = undefined
        }
      }
    }

    if (isDown('rightclick')) {
      if (selectedPoint) {
        selectedPoint = undefined
      } else {
        if (hoverPoint === undefined) {
          addPoint(nearX, nearY)
        }
      }
    }

    if (handle('mousemove')) {
      if (drag) {
        applyPanAndScale()
      } else {
        mouseRelX = (mouseX - bounding.x) / bounding.width * S - 0.5
        mouseRelY = (mouseY - bounding.y) / bounding.height * S - 0.5

        hoverX = (mouseRelX - posX) / scale
        hoverY = (mouseRelY - posY) / scale

        nearX = Math.round(hoverX)
        nearY = Math.round(hoverY)

        hoverPoint = isNear(hoverX) && isNear(hoverY) && graph[nearX * S + nearY]
        drawSelection()
      }
    }

    for (const key of inputsUp) {
      inputsUp.delete(key)
      inputsDown.delete(key)
    }

    now = Date.now()
    updateRequested = inputsDown.size && requestAnimationFrame(executeUpdate)
  }

  let updateRequested = requestAnimationFrame(executeUpdate)
  const update = eventName => {
    updateRequested || (updateRequested = requestAnimationFrame(executeUpdate))
    events.add(eventName)
  }
  const svgWheel = e => {
    e.preventDefault()
    scale = scale + Math.sign(e.deltaY) * (scale / 20)
    update('resize')
  }
  const preventDefault = e => e.preventDefault()
  const windowMousemove = e => {
    mouseX = e.x ? e.x : e.clientX
    mouseY = e.y ? e.y : e.clientY
    update('mousemove')
  }
  const windowBlur = e => update('blur')
  const windowResize = () => update('resize')
  const windowKeyup = e => inputsUp.add(e.key)
  const windowKeydown = ({ key }) => {
    if (inputsDown.has(key)) return
    inputsDown.set(key, Date.now())
    update('keyboard')
  }

  const svgMouseup = e => {
    e.preventDefault()
    mouseX = e.x ? e.x : e.clientX
    mouseY = e.y ? e.y : e.clientY
    const name = getClickName(e)
    name && inputsUp.add(name)
    update('mousemove')
  }

  const svgMousedown = e => {
    e.preventDefault()
    mouseX = e.x ? e.x : e.clientX
    mouseY = e.y ? e.y : e.clientY
    const name = getClickName(e)
    name && inputsDown.set(name, Date.now())
    update('mousemove')
  }

  grid.forEach(dot => group.appendChild(dot))
  group.appendChild(hoverMarker)
  group.appendChild(linkPreview)
  svg.appendChild(group)
  svg.appendChild(Circle({
    cx: (S/2)-0.5,
    cy: (S/2)-0.5,
    r: 0.06,
    fill: 'transparent',
    'stroke-width': 0.005,
    stroke: `hsla(0,0%,100%,0.4)`
  }))


  let observer
  if (window.ResizeObserver) {
    observer = new ResizeObserver(windowResize).observe(svg)
  } else {
    window.addEventListener('resize', windowResize, { passive: true })
  }
  svg.addEventListener('wheel', svgWheel, { passive: false })
  svg.addEventListener('mouseup', svgMouseup)
  svg.addEventListener('mousedown', svgMousedown)
  svg.addEventListener('contextmenu', preventDefault)
  window.addEventListener('blur', windowBlur)
  window.addEventListener('keyup', windowKeyup)
  window.addEventListener('keydown', windowKeydown)
  window.addEventListener('mousemove', windowMousemove)

  params.mountingPoint.appendChild(svg)
  bounding = svg.getBoundingClientRect()
  return () => {
    cancelAnimationFrame(updateRequested)
    updateRequested = true
    if (observer) {
      observer.unobserve(svg)
    } else {
      window.removeEventListener('resize', windowResize)
    }
    svg.removeEventListener('wheel', svgWheel)
    svg.removeEventListener('mouseup', svgMouseup)
    svg.removeEventListener('mousedown', svgMousedown)
    svg.removeEventListener('contextmenu', preventDefault)
    window.removeEventListener('blur', windowBlur)
    window.removeEventListener('keyup', windowKeyup)
    window.removeEventListener('keydown', windowKeydown)
    window.removeEventListener('mousemove', windowMousemove)
  }
}

init({
  size: 21,
  mountingPoint: document.body,
  listenner: console.log
})

init({
  size: 3,
  mountingPoint: document.body,
})
</script>
</head>
<body>
</body>
</html>
